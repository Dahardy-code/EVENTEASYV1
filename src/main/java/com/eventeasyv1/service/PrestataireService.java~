package com.eventeasyv1.service;

import com.eventeasyv1.dao.PrestataireRepository;
import com.eventeasyv1.dao.ServiceRepository;
import com.eventeasyv1.dao.DisponibiliteRepository;
import com.eventeasyv1.dto.PrestataireDto;
import com.eventeasyv1.dto.ServiceDto;
import com.eventeasyv1.dto.input.ServiceCreateUpdateDto;
import com.eventeasyv1.entities.Prestataire;
import com.eventeasyv1.entities.Service;
import com.eventeasyv1.entities.Disponibilite;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class PrestataireService {

    private static final Logger log = LoggerFactory.getLogger(PrestataireService.class);

    private final PrestataireRepository prestataireRepository;
    private final ServiceRepository serviceRepository;
    private final DisponibiliteRepository disponibiliteRepository;

    @Autowired
    public PrestataireService(PrestataireRepository prestataireRepository,
                              ServiceRepository serviceRepository,
                              DisponibiliteRepository disponibiliteRepository) {
        this.prestataireRepository = prestataireRepository;
        this.serviceRepository = serviceRepository;
        this.disponibiliteRepository = disponibiliteRepository;
    }

    private Prestataire getCurrentAuthenticatedPrestataire() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated() || "anonymousUser".equals(authentication.getPrincipal())) {
            log.warn("Tentative d'accès getCurrentAuthenticatedPrestataire sans authentification valide.");
            throw new IllegalStateException("Aucun utilisateur authentifié trouvé ou session expirée.");
        }
        String userEmail = authentication.getName();
        return prestataireRepository.findByEmail(userEmail)
                .orElseThrow(() -> new UsernameNotFoundException("Prestataire non trouvé avec l'email: " + userEmail));
    }

    @Transactional(readOnly = true)
    public PrestataireDto getCurrentPrestataireDetails() {
        Prestataire prestataire = getCurrentAuthenticatedPrestataire();
        return mapPrestataireToDto(prestataire);
    }

    @Transactional(readOnly = true)
    public List<ServiceDto> getMyServices() {
        Prestataire currentPrestataire = getCurrentAuthenticatedPrestataire();
        log.debug("Récupération des services pour le prestataire ID: {}", currentPrestataire.getId());
        List<Service> services = serviceRepository.findByPrestataireId(currentPrestataire.getId());
        return services.stream().map(this::mapServiceToDto).collect(Collectors.toList());
    }

    @Transactional
    public ServiceDto addMyService(ServiceCreateUpdateDto serviceDto) {
        Prestataire currentPrestataire = getCurrentAuthenticatedPrestataire();
        log.info("Ajout d'un service par le prestataire ID: {}, Titre: {}", currentPrestataire.getId(), serviceDto.getTitre());

        Service newService = new Service();
        newService.setTitre(serviceDto.getTitre());
        newService.setDescription(serviceDto.getDescription());
        newService.setPrix(serviceDto.getPrix());
        newService.setCategorie(serviceDto.getCategorie());
        newService.setPrestataire(currentPrestataire);

        Service savedService = serviceRepository.save(newService);
        log.info("Service ID: {} créé avec succès pour le prestataire ID: {}", savedService.getId(), currentPrestataire.getId());
        return mapServiceToDto(savedService);
    }

    @Transactional
    public ServiceDto updateMyService(Long serviceId, ServiceCreateUpdateDto serviceDto) {
        Prestataire currentPrestataire = getCurrentAuthenticatedPrestataire();
        log.info("Mise à jour du service ID: {} par le prestataire ID: {}", serviceId, currentPrestataire.getId());

        Service service = (Service) serviceRepository.findByIdAndPrestataireId(serviceId, currentPrestataire.getId())
                .orElseThrow(() -> {
                    log.warn("Tentative de mise à jour non autorisée du service ID: {} par le prestataire ID: {}", serviceId, currentPrestataire.getId());
                    return new AccessDeniedException("Vous n'êtes pas autorisé à modifier ce service.");
                });

        service.setTitre(serviceDto.getTitre());
        service.setDescription(serviceDto.getDescription());
        service.setPrix(serviceDto.getPrix());
        service.setCategorie(serviceDto.getCategorie());

        Service updatedService = serviceRepository.save(service);
        log.info("Service ID: {} mis à jour avec succès.", updatedService.getId());
        return mapServiceToDto(updatedService);
    }

    @Transactional
    public void deleteMyService(Long serviceId) {
        Prestataire currentPrestataire = getCurrentAuthenticatedPrestataire();
        log.info("Suppression du service ID: {} par le prestataire ID: {}", serviceId, currentPrestataire.getId());

        Service service = (Service) serviceRepository.findByIdAndPrestataireId(serviceId, currentPrestataire.getId())
                .orElseThrow(() -> {
                    log.warn("Tentative de suppression non autorisée du service ID: {} par le prestataire ID: {}", serviceId, currentPrestataire.getId());
                    return new AccessDeniedException("Vous n'êtes pas autorisé à supprimer ce service.");
                });

        serviceRepository.delete(service);
        log.info("Service ID: {} supprimé avec succès.", serviceId);
    }

    private PrestataireDto mapPrestataireToDto(Prestataire prestataire) {
        PrestataireDto dto = new PrestataireDto();
        dto.setId(prestataire.getId());
        dto.setNom(prestataire.getNom());
        dto.setPrenom(prestataire.getPrenom());
        dto.setEmail(prestataire.getEmail());
        dto.setNomEntreprise(prestataire.getNomEntreprise());
        dto.setCategorieService(prestataire.getCategorieService());
        dto.setAdresse(prestataire.getAdresse());
        dto.setNumeroTel(prestataire.getNumeroTel());
        return dto;
    }

    private ServiceDto mapServiceToDto(Service service) {
        ServiceDto dto = new ServiceDto();
        dto.setId(service.getId());
        dto.setTitre(service.getTitre());
        dto.setDescription(service.getDescription());
        dto.setPrix(service.getPrix());
        dto.setCategorie(service.getCategorie());
        if (service.getPrestataire() != null) {
            dto.setPrestataireId(service.getPrestataire().getId());
            dto.setNomEntreprisePrestataire(service.getPrestataire().getNomEntreprise());
        }
        return dto;
    }

    public List<Object> getMyDisponibilites() {
        Prestataire currentPrestataire = getCurrentAuthenticatedPrestataire();
        log.debug("Récupération des disponibilités pour le prestataire ID: {}", currentPrestataire.getId());
        List<Disponibilite> disponibilites = disponibiliteRepository.findByPrestataireId(currentPrestataire.getId());
        return disponibilites.stream().map(this::mapDisponibiliteToDto).collect(Collectors.toList()).reversed();
    }

    private Object mapDisponibiliteToDto(Disponibilite disponibilite) {
        return null;
    }
}